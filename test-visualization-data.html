<!DOCTYPE html>
<html>
<head>
    <title>Visualization Data Test</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        #graph { border: 1px solid #ccc; }
        .info { margin: 20px; font-family: Arial, sans-serif; }
        .node { stroke: #fff; stroke-width: 1.5px; }
        .link { stroke: #999; stroke-opacity: 0.6; }
    </style>
</head>
<body>
    <div class="info">
        <h1>Testing Visualization Data Flow</h1>
        <div id="status"></div>
        <svg id="graph" width="800" height="600"></svg>
    </div>

    <script>
        async function testVisualization() {
            const statusDiv = document.getElementById('status');
            let statusHTML = '<h2>Data Loading Status:</h2><ul>';

            try {
                // 1. Fetch nodes
                const nodesResp = await fetch('http://localhost:8084/api/graph/nodes?limit=500');
                const nodesData = await nodesResp.json();
                statusHTML += `<li>✅ <strong>Nodes loaded: ${nodesData.nodes?.length || 0} / ${nodesData.total}</strong></li>`;

                // 2. Fetch edges
                const edgesResp = await fetch('http://localhost:8084/api/graph/edges?limit=5000');
                const edgesData = await edgesResp.json();
                statusHTML += `<li>✅ <strong>Edges loaded: ${edgesData.edges?.length || 0} / ${edgesData.total}</strong></li>`;

                // 3. Transform data for D3
                const nodes = nodesData.nodes.map(n => ({
                    id: n.id,
                    label: n.metadata?.label || n.id,
                    type: n.metadata?.node_type || 'unknown'
                }));

                const links = edgesData.edges.map(e => ({
                    source: e.source_id,
                    target: e.target_id,
                    weight: e.weight || 1
                }));

                statusHTML += `<li>✅ <strong>Ready for D3: ${nodes.length} nodes, ${links.length} links</strong></li>`;

                // 4. Filter to only songs (not artists)
                const songNodes = nodes.filter(n => n.type === 'song');
                const songNodeIds = new Set(songNodes.map(n => n.id));
                const songLinks = links.filter(l =>
                    songNodeIds.has(l.source) && songNodeIds.has(l.target)
                );

                statusHTML += `<li>✅ <strong>Songs only: ${songNodes.length} nodes, ${songLinks.length} links</strong></li>`;
                statusHTML += '</ul>';

                // 5. Create simple D3 visualization
                const svg = d3.select("#graph");
                const width = 800;
                const height = 600;

                // Clear previous
                svg.selectAll("*").remove();

                // Create simulation
                const simulation = d3.forceSimulation(songNodes)
                    .force("link", d3.forceLink(songLinks).id(d => d.id).distance(50))
                    .force("charge", d3.forceManyBody().strength(-300))
                    .force("center", d3.forceCenter(width / 2, height / 2));

                // Draw links
                const link = svg.append("g")
                    .selectAll("line")
                    .data(songLinks)
                    .join("line")
                    .attr("class", "link")
                    .attr("stroke-width", d => Math.sqrt(d.weight));

                // Draw nodes
                const node = svg.append("g")
                    .selectAll("circle")
                    .data(songNodes)
                    .join("circle")
                    .attr("class", "node")
                    .attr("r", 5)
                    .attr("fill", "#69b3a2");

                // Add labels
                const labels = svg.append("g")
                    .selectAll("text")
                    .data(songNodes)
                    .join("text")
                    .text(d => d.label)
                    .style("font-size", "8px")
                    .attr("dx", 8)
                    .attr("dy", 3);

                // Update positions
                simulation.on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    node
                        .attr("cx", d => d.x)
                        .attr("cy", d => d.y);

                    labels
                        .attr("x", d => d.x)
                        .attr("y", d => d.y);
                });

                statusHTML += '<h3>✅ Visualization rendered successfully!</h3>';
                statusHTML += `<p>The graph shows ${songNodes.length} songs connected by ${songLinks.length} adjacency relationships.</p>`;
                statusHTML += '<p>If this test page works but the main frontend doesn\'t, check:</p>';
                statusHTML += '<ul>';
                statusHTML += '<li>Frontend GraphService configuration (should use port 8084)</li>';
                statusHTML += '<li>Redux state management for graph data</li>';
                statusHTML += '<li>React component rendering logic</li>';
                statusHTML += '</ul>';

            } catch (e) {
                statusHTML += `<li>❌ Error: ${e.message}</li></ul>`;
            }

            statusDiv.innerHTML = statusHTML;
        }

        testVisualization();
    </script>
</body>
</html>