import React, { useRef, useEffect, useState } from 'react';
import { clusterNodes } from '../../utils/cluster';
import * as PIXI from 'pixi.js';
import { useDrag, usePinch } from '@use-gesture/react';
import { useSpring, animated } from '@react-spring/web';

interface PixiCanvasProps {
  width: number;
  height: number;
  nodes: any[];
  edges: any[];
  onNodeRightClick?: (node: any, event: React.MouseEvent) => void;
}

export const PixiCanvas: React.FC<PixiCanvasProps> = ({ width, height, nodes, edges, onNodeRightClick }) => {
  const canvasRef = useRef<HTMLDivElement>(null);
  const appRef = useRef<PIXI.Application | null>(null);

  const [{ x, y, scale }, api] = useSpring(() => ({
    x: 0,
    y: 0,
    scale: 1,
    config: { mass: 1, tension: 500, friction: 50 },
  }));

  useDrag(
    ({ offset: [dx, dy] }) => {
      api.start({ x: dx, y: dy });
    },
    {
      target: canvasRef,
    }
  );

  usePinch(
    ({ offset: [s] }) => {
      api.start({ scale: s });
    },
    {
      target: canvasRef,
      eventOptions: { passive: false },
    }
  );

  useEffect(() => {
    if (!canvasRef.current) return;

    const app = new PIXI.Application({
      width,
      height,
      backgroundColor: 0x0F172A,
      antialias: true,
      resolution: window.devicePixelRatio || 1,
      autoDensity: true,
    });

    appRef.current = app;
    canvasRef.current.appendChild(app.view as unknown as Node);

    const container = new PIXI.Container();
    app.stage.addChild(container);

    const graphics = new PIXI.Graphics();
    container.addChild(graphics);

    // Update container position and scale based on spring values
    const updateContainer = () => {
      container.x = x.get();
      container.y = y.get();
      container.scale.set(scale.get());
    };

    const draw = () => {
        graphics.clear();

        const zoom = scale.get();
        const clusteredNodes = clusterNodes(nodes, zoom);

        const screenWidth = app.renderer.width / zoom;
        const screenHeight = app.renderer.height / zoom;
        const screenX = -container.x / zoom;
        const screenY = -container.y / zoom;

        const visibleNodes = clusteredNodes.filter(node => {
          return node.x > screenX - 50 && node.x < screenX + screenWidth + 50 &&
                 node.y > screenY - 50 && node.y < screenY + screenHeight + 50;
        });

        const visibleNodeIds = new Set(visibleNodes.map(n => n.id));
        const visibleEdges = edges.filter(edge =>
          visibleNodeIds.has(edge.source) && visibleNodeIds.has(edge.target)
        );

        // Draw edges
        visibleEdges.forEach(edge => {
          const source = visibleNodes.find(n => n.id === edge.source);
          const target = visibleNodes.find(n => n.id === edge.target);
          if (source && target) {
            const lineWidth = zoom > 0.5 ? 1 : 0.5;
            graphics.lineStyle(lineWidth, 0x999999, 0.5);
            graphics.moveTo(source.x, source.y);
            graphics.lineTo(target.x, target.y);
          }
        });

        // Draw nodes
        visibleNodes.forEach(node => {
          const nodeGraphic = new PIXI.Graphics();
          if (node.isCluster) {
            const clusterRadius = 5 + Math.sqrt(node.size) * 2;
            nodeGraphic.beginFill(0x00ff00, 0.5);
            nodeGraphic.drawCircle(node.x, node.y, clusterRadius);
            nodeGraphic.endFill();
          } else {
            const nodeRadius = 5;
            nodeGraphic.beginFill(0x00ff00, 1);
            nodeGraphic.drawCircle(node.x, node.y, nodeRadius);
            nodeGraphic.endFill();
          }
          nodeGraphic.interactive = true;
          nodeGraphic.buttonMode = true;
          nodeGraphic.on('rightclick', (event) => {
            if (onNodeRightClick) {
              onNodeRightClick(node, event.data.originalEvent as unknown as React.MouseEvent);
            }
          });
          graphics.addChild(nodeGraphic);
        });
    };

    // Animation loop
    const animate = () => {
      updateContainer();
      draw();
    };

    app.ticker.add(animate);

    return () => {
      app.ticker.remove(animate);
      app.destroy(true, { children: true, texture: true, baseTexture: true });
      appRef.current = null;
    };
  }, [width, height, nodes, edges, x, y, scale, onNodeRightClick]);

  return <div ref={canvasRef} style={{ width, height, touchAction: 'none' }} />;
};