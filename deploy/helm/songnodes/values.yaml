global:
  namespace: songnodes
  imagePullSecrets: []
  configMapName: songnodes-config
  secretName: songnodes-secrets
  commonLabels:
    app.kubernetes.io/part-of: songnodes
  commonAnnotations:
    deployment.kubernetes.io/revision: "1"

namespace:
  create: true
  name: songnodes
  labels: {}
  annotations: {}

config:
  create: true
  name: songnodes-config
  labels:
    app.kubernetes.io/name: songnodes
    app.kubernetes.io/component: config
  annotations: {}
  data:
    POSTGRES_HOST: postgres-0.postgres-service
    POSTGRES_PORT: "5432"
    POSTGRES_DB: musicdb
    POSTGRES_USER: musicdb_user
    REDIS_HOST: redis-service
    REDIS_PORT: "6379"
    RABBITMQ_HOST: rabbitmq-service
    RABBITMQ_PORT: "5672"
    RABBITMQ_USER: songnodesuser
    REST_API_HOST: rest-api
    REST_API_PORT: "8082"
    GRAPH_API_HOST: graph-visualization
    GRAPH_API_PORT: "8084"
    WEBSOCKET_API_HOST: websocket-api
    WEBSOCKET_API_PORT: "8083"
    METADATA_ENRICHMENT_HOST: metadata-enrichment
    METADATA_ENRICHMENT_PORT: "8020"
    METADATA_ENRICHMENT_URL: http://metadata-enrichment:8020
    ENVIRONMENT: production
    LOG_LEVEL: INFO
    CORS_ALLOWED_ORIGINS: "*"
    SCRAPER_CONCURRENT_REQUESTS: "16"
    SCRAPER_DOWNLOAD_DELAY: "2.0"
    SCRAPER_AUTOTHROTTLE_ENABLED: "True"
    PROMETHEUS_ENABLED: "true"
    METRICS_PORT: "9090"

secrets:
  create: true
  name: songnodes-secrets
  type: Opaque
  labels:
    app.kubernetes.io/name: songnodes
    app.kubernetes.io/component: secrets
  annotations: {}
  stringData:
    POSTGRES_PASSWORD: CHANGE_ME_musicdb_secure_pass_2024
    REDIS_PASSWORD: CHANGE_ME_redis_secure_pass_2024
    RABBITMQ_PASS: CHANGE_ME_rabbitmq_secure_pass_2024
    DATABASE_URL: postgresql+asyncpg://musicdb_user:CHANGE_ME_musicdb_secure_pass_2024@postgres-0.postgres-service.songnodes.svc.cluster.local:5432/musicdb
    SPOTIFY_CLIENT_ID: CHANGE_ME
    SPOTIFY_CLIENT_SECRET: CHANGE_ME
    TIDAL_CLIENT_ID: CHANGE_ME
    TIDAL_CLIENT_SECRET: CHANGE_ME
    TIDAL_API_TOKEN: CHANGE_ME
    LASTFM_API_KEY: CHANGE_ME
    YOUTUBE_API_KEY: CHANGE_ME
    DISCOGS_API_TOKEN: CHANGE_ME
    ANTHROPIC_API_KEY: CHANGE_ME
    PROXY_USERNAME: ""
    PROXY_PASSWORD: ""

postgres:
  enabled: true
  nameOverride: postgres
  replicaCount: 1
  service:
    type: ClusterIP
    port: 5432
    annotations: {}
    headless: true
  image:
    repository: postgres
    tag: 15-alpine
    pullPolicy: IfNotPresent
  env:
    pgdata: /var/lib/postgresql/data/pgdata
  persistence:
    enabled: true
    accessModes:
      - ReadWriteOnce
    size: 20Gi
    storageClassName: ""
  resources:
    requests:
      memory: 256Mi
      cpu: 100m
    limits:
      memory: 512Mi
      cpu: 500m
  readinessProbe:
    enabled: true
    exec:
        command:
        - /bin/sh
        - -c
        - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
  livenessProbe:
    enabled: true
    exec:
        command:
        - /bin/sh
        - -c
        - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  initScripts:
    createConfigMap: true
    name: postgres-init-scripts
    data:
      README.md: |
        PostgreSQL initialization scripts should be mounted here.
        Copy contents from sql/init/ directory to this ConfigMap.

        Example:
        kubectl create configmap postgres-init-scripts \
          --from-file=sql/init/ \
          -n songnodes
  backup:
    enabled: true
    schedule: "0 2 * * *"  # Daily at 2 AM
    retentionDays: 7
    storageSize: 10Gi
    storageClassName: local-path
    resources:
      requests:
        memory: 128Mi
        cpu: 50m
      limits:
        memory: 256Mi
        cpu: 200m

redis:
  enabled: true
  nameOverride: redis
  replicaCount: 1
  service:
    type: ClusterIP
    port: 6379
    annotations: {}
  image:
    repository: redis
    tag: 7-alpine
    pullPolicy: IfNotPresent
  command:
    - redis-server
    - --requirepass
    - $(REDIS_PASSWORD)
    - --maxmemory
    - 32mb
    - --maxmemory-policy
    - allkeys-lru
    - --save
    - "900 1"
    - --save
    - "300 10"
    - --save
    - "60 10000"
  persistence:
    enabled: true
    existingClaim: ""
    accessModes:
      - ReadWriteOnce
    size: 5Gi
    storageClassName: ""
  resources:
    requests:
      memory: 16Mi
      cpu: 10m
    limits:
      memory: 32Mi
      cpu: 100m
  readinessProbe:
    enabled: true
    exec:
        command:
        - redis-cli
        - --pass
        - $(REDIS_PASSWORD)
        - ping
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
  livenessProbe:
    enabled: true
    exec:
        command:
        - redis-cli
        - --pass
        - $(REDIS_PASSWORD)
        - ping
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

rabbitmq:
  enabled: true
  nameOverride: rabbitmq
  replicaCount: 1
  service:
    type: ClusterIP
    ports:
      amqp: 5672
      management: 15672
    annotations: {}
    headless: true
  image:
    repository: rabbitmq
    tag: 3.12-management-alpine
    pullPolicy: IfNotPresent
  erlangCookie: songnodes-secret-cookie
  persistence:
    enabled: true
    accessModes:
      - ReadWriteOnce
    size: 10Gi
    storageClassName: ""
  resources:
    requests:
      memory: 192Mi
      cpu: 100m
    limits:
      memory: 384Mi
      cpu: 500m
  readinessProbe:
    enabled: true
    exec:
        command:
        - rabbitmq-diagnostics
        - -q
        - check_port_connectivity
    initialDelaySeconds: 20
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  livenessProbe:
    enabled: true
    exec:
        command:
        - rabbitmq-diagnostics
        - -q
        - ping
    initialDelaySeconds: 60
    periodSeconds: 30
    timeoutSeconds: 10
    failureThreshold: 3

services:
  restApi:
    enabled: true
    name: rest-api
    component: backend
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_rest-api
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8082
          targetPort: 8082
        metrics:
          port: 9090
          targetPort: 9090
    podAnnotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9090"
      prometheus.io/path: /metrics
    containerPorts:
      http: 8082
      metrics: 9090
    env:
      config:
        - POSTGRES_HOST
        - POSTGRES_PORT
        - POSTGRES_DB
        - POSTGRES_USER
        - REDIS_HOST
        - REDIS_PORT
        - LOG_LEVEL
        - ENVIRONMENT
      secret:
        POSTGRES_PASSWORD: POSTGRES_PASSWORD
        REDIS_PASSWORD: REDIS_PASSWORD
        DATABASE_URL: DATABASE_URL
    extraEnv: []
    initContainers:
      - name: wait-for-postgres
        image: postgres:15-alpine
        command:
          - sh
          - -c
          - |
            for i in $(seq 1 40); do
              pg_isready -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d "$POSTGRES_DB" && exit 0
              echo "Waiting for postgres at $POSTGRES_HOST:$POSTGRES_PORT..."
              sleep 3
            done
            echo "Postgres not reachable, giving up."
            exit 1
        env:
          - name: POSTGRES_HOST
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_HOST
          - name: POSTGRES_PORT
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_PORT
          - name: POSTGRES_DB
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_DB
          - name: POSTGRES_USER
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_USER
          - name: PGPASSWORD
            valueFrom:
              secretKeyRef:
                name: songnodes-secrets
                key: POSTGRES_PASSWORD
    resources:
      requests:
        memory: 96Mi
        cpu: 50m
      limits:
        memory: 192Mi
        cpu: 200m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 5
        failureThreshold: 3
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 10
        periodSeconds: 5
        timeoutSeconds: 3
        failureThreshold: 3
      startup:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 0
        periodSeconds: 5
        timeoutSeconds: 3
        failureThreshold: 30

  graphVisualization:
    enabled: true
    name: graph-visualization
    component: backend
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_graph-visualization-api
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8084
          targetPort: 8084
        metrics:
          port: 9090
          targetPort: 9090
    podAnnotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9090"
    containerPorts:
      http: 8084
      metrics: 9090
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 96Mi
        cpu: 50m
      limits:
        memory: 192Mi
        cpu: 200m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 10
        periodSeconds: 5

  websocketApi:
    enabled: true
    name: websocket-api
    component: backend
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_websocket-api
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8083
          targetPort: 8083
    containerPorts:
      http: 8083
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 96Mi
        cpu: 50m
      limits:
        memory: 192Mi
        cpu: 200m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 20
        periodSeconds: 10
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 10
        periodSeconds: 5

  nlpProcessor:
    enabled: true
    name: nlp-processor
    component: backend
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_nlp-processor
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8086
          targetPort: 8086
    containerPorts:
      http: 8086
    envFrom:
      configMap: true
      secret: true
    extraEnv:
      - name: OLLAMA_HOST
        value: "http://ollama-maxwell.phoenix.svc.cluster.local:11434"
      - name: OLLAMA_MODEL
        value: "llama3.2:latest"
    resources:
      requests:
        memory: 256Mi
        cpu: 100m
      limits:
        memory: 512Mi
        cpu: 500m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 10
        periodSeconds: 5

  scraperOrchestrator:
    enabled: true
    name: scraper-orchestrator
    component: scraper
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_scraper-orchestrator
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8001
          targetPort: 8001
    containerPorts:
      http: 8001
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 128Mi
        cpu: 50m
      limits:
        memory: 256Mi
        cpu: 200m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 10
        periodSeconds: 5

  scraper1001tracklists:
    enabled: false  # Replaced by unifiedScraper
    name: scraper-1001tracklists
    component: scraper
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_scraper-1001tracklists
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8011
          targetPort: 8011
    containerPorts:
      http: 8011
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 1000m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 60
        periodSeconds: 15
        timeoutSeconds: 20
        failureThreshold: 5
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 20
        failureThreshold: 5

  scraperMixesdb:
    enabled: false  # Replaced by unifiedScraper
    name: scraper-mixesdb
    component: scraper
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_scraper-mixesdb
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8012
          targetPort: 8012
    containerPorts:
      http: 8012
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 1000m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 60
        periodSeconds: 15
        timeoutSeconds: 20
        failureThreshold: 5
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 20
        failureThreshold: 5

  scraperSetlistfm:
    enabled: false  # Replaced by unifiedScraper
    name: scraper-setlistfm
    component: scraper
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_scraper-setlistfm
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8013
          targetPort: 8013
    containerPorts:
      http: 8013
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 1000m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 60
        periodSeconds: 15
        timeoutSeconds: 20
        failureThreshold: 5
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 20
        failureThreshold: 5

  scraperReddit:
    enabled: false  # Replaced by unifiedScraper
    name: scraper-reddit
    component: scraper
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_scraper-reddit
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8014
          targetPort: 8014
    containerPorts:
      http: 8014
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 1000m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 60
        periodSeconds: 15
        timeoutSeconds: 20
        failureThreshold: 5
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 20
        failureThreshold: 5

  scraperMixcloud:
    enabled: false  # Replaced by unifiedScraper
    name: scraper-mixcloud
    component: scraper
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_scraper-mixcloud
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8015
          targetPort: 8015
    containerPorts:
      http: 8015
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 1000m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 60
        periodSeconds: 15
        timeoutSeconds: 20
        failureThreshold: 5
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 20
        failureThreshold: 5

  scraperSoundcloud:
    enabled: false  # Replaced by unifiedScraper
    name: scraper-soundcloud
    component: scraper
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_scraper-soundcloud
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8016
          targetPort: 8016
    containerPorts:
      http: 8016
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 1000m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 60
        periodSeconds: 15
        timeoutSeconds: 20
        failureThreshold: 5
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 20
        failureThreshold: 5

  scraperYoutube:
    enabled: false  # Replaced by unifiedScraper
    name: scraper-youtube
    component: scraper
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_scraper-youtube
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8017
          targetPort: 8017
    containerPorts:
      http: 8017
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 1000m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 60
        periodSeconds: 15
        timeoutSeconds: 20
        failureThreshold: 5
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 20
        failureThreshold: 5

  scraperInternetarchive:
    enabled: false  # Replaced by unifiedScraper
    name: scraper-internetarchive
    component: scraper
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_scraper-internetarchive
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8018
          targetPort: 8018
    containerPorts:
      http: 8018
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 1000m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 60
        periodSeconds: 15
        timeoutSeconds: 20
        failureThreshold: 5
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 20
        failureThreshold: 5

  scraperLivetracklist:
    enabled: false  # Replaced by unifiedScraper
    name: scraper-livetracklist
    component: scraper
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_scraper-livetracklist
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8019
          targetPort: 8019
    containerPorts:
      http: 8019
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 1000m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 60
        periodSeconds: 15
        timeoutSeconds: 20
        failureThreshold: 5
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 20
        failureThreshold: 5

  scraperResidentadvisor:
    enabled: false  # Replaced by unifiedScraper
    name: scraper-residentadvisor
    component: scraper
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_scraper-residentadvisor
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8023
          targetPort: 8023
    containerPorts:
      http: 8023
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 1000m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 60
        periodSeconds: 15
        timeoutSeconds: 20
        failureThreshold: 5
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 20
        failureThreshold: 5

  scraperBbcSounds:
    enabled: false  # Replaced by unifiedScraper
    name: scraper-bbc-sounds
    component: scraper
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_scraper-bbc-sounds
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8026
          targetPort: 8026
    containerPorts:
      http: 8026
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 1000m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 60
        periodSeconds: 15
        timeoutSeconds: 20
        failureThreshold: 5
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 20
        failureThreshold: 5

  # Unified Scraper - Consolidates all 11 scrapers into a single service
  unifiedScraper:
    enabled: true
    name: unified-scraper
    component: scraper
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_unified-scraper
      tag: latest
      pullPolicy: Always
    command:
      - python
      - -m
      - uvicorn
      - unified_scraper_api:app
      - --host
      - "0.0.0.0"
      - --port
      - "8000"
    service:
      type: ClusterIP
      ports:
        http:
          port: 8000
          targetPort: 8000
    containerPorts:
      http: 8000
    envFrom:
      configMap: true
      secret: true
    env:
      static:
        METADATA_ENRICHMENT_URL: "http://metadata-enrichment:8020"
        LOG_LEVEL: "INFO"
        PYTHONUNBUFFERED: "1"
    resources:
      requests:
        memory: 64Mi
        cpu: 50m
      limits:
        memory: 128Mi
        cpu: 200m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 15
        timeoutSeconds: 5
        failureThreshold: 3
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 15
        periodSeconds: 10
        timeoutSeconds: 5
        failureThreshold: 3
    initContainers:
      - name: wait-for-postgres
        image: postgres:15-alpine
        command:
          - sh
          - -c
          - |
            until pg_isready -h postgres-0.postgres-service.songnodes.svc.cluster.local -p 5432 -U musicdb_user; do
              echo "Waiting for postgres at postgres-0.postgres-service.songnodes.svc.cluster.local:5432..."
              sleep 2
            done
            echo "postgres-0.postgres-service.songnodes.svc.cluster.local:5432 - accepting connections"

  metadataEnrichment:
    enabled: true
    name: metadata-enrichment
    component: enrichment
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_metadata-enrichment
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8020
          targetPort: 8020
        metrics:
          port: 9090
          targetPort: 9090
    podAnnotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9090"
      prometheus.io/path: /metrics
    containerPorts:
      http: 8020
      metrics: 9090
    env:
      config:
        - POSTGRES_HOST
        - POSTGRES_PORT
        - POSTGRES_DB
        - POSTGRES_USER
        - REDIS_HOST
        - REDIS_PORT
        - LOG_LEVEL
        - ENVIRONMENT
      secret:
        DATABASE_URL: DATABASE_URL
        POSTGRES_PASSWORD: POSTGRES_PASSWORD
        REDIS_PASSWORD: REDIS_PASSWORD
        SPOTIFY_CLIENT_ID: SPOTIFY_CLIENT_ID
        SPOTIFY_CLIENT_SECRET: SPOTIFY_CLIENT_SECRET
        TIDAL_CLIENT_ID: TIDAL_CLIENT_ID
        TIDAL_CLIENT_SECRET: TIDAL_CLIENT_SECRET
        LASTFM_API_KEY: LASTFM_API_KEY
        DISCOGS_API_TOKEN: DISCOGS_API_TOKEN
    initContainers:
      - name: wait-for-postgres
        image: postgres:15-alpine
        command:
          - sh
          - -c
          - |
            for i in $(seq 1 40); do
              pg_isready -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d "$POSTGRES_DB" && exit 0
              echo "Waiting for postgres at $POSTGRES_HOST:$POSTGRES_PORT..."
              sleep 3
            done
            echo "Postgres not reachable, giving up."
            exit 1
        env:
          - name: POSTGRES_HOST
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_HOST
          - name: POSTGRES_PORT
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_PORT
          - name: POSTGRES_DB
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_DB
          - name: POSTGRES_USER
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_USER
          - name: PGPASSWORD
            valueFrom:
              secretKeyRef:
                name: songnodes-secrets
                key: POSTGRES_PASSWORD
      - name: wait-for-redis
        image: redis:7-alpine
        command:
          - sh
          - -c
          - |
            for i in $(seq 1 30); do
              redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" -a "$REDIS_PASSWORD" ping && exit 0
              echo "Waiting for redis at $REDIS_HOST:$REDIS_PORT..."
              sleep 2
            done
            echo "Redis not reachable, giving up."
            exit 1
        env:
          - name: REDIS_HOST
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: REDIS_HOST
          - name: REDIS_PORT
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: REDIS_PORT
          - name: REDIS_PASSWORD
            valueFrom:
              secretKeyRef:
                name: songnodes-secrets
                key: REDIS_PASSWORD
    resources:
      requests:
        memory: 128Mi
        cpu: 50m
      limits:
        memory: 256Mi
        cpu: 200m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 60
        periodSeconds: 15
        timeoutSeconds: 15
        failureThreshold: 5
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10
        failureThreshold: 5
      startup:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 0
        periodSeconds: 10
        timeoutSeconds: 10
        failureThreshold: 60

  rawDataProcessor:
    enabled: false  # Disabled: missing service ports configuration
    name: raw-data-processor
    component: processor
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_raw-data-processor
      tag: latest
      pullPolicy: Always
    env:
      config:
        - POSTGRES_HOST
        - POSTGRES_PORT
        - POSTGRES_DB
        - POSTGRES_USER
        - LOG_LEVEL
      secret:
        POSTGRES_PASSWORD: POSTGRES_PASSWORD
        DATABASE_PASSWORD: POSTGRES_PASSWORD
      static:
        DATABASE_HOST: postgres-0.postgres-service
        DATABASE_PORT: "5432"
        DATABASE_NAME: musicdb
        DATABASE_USER: musicdb_user
        PROCESSING_INTERVAL: "30"
        BATCH_SIZE: "200"
    initContainers:
      - name: wait-for-postgres
        image: postgres:15-alpine
        command:
          - sh
          - -c
          - |
            for i in $(seq 1 40); do
              pg_isready -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d "$POSTGRES_DB" && exit 0
              echo "Waiting for postgres at $POSTGRES_HOST:$POSTGRES_PORT..."
              sleep 3
            done
            echo "Postgres not reachable, giving up."
            exit 1
        env:
          - name: POSTGRES_HOST
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_HOST
          - name: POSTGRES_PORT
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_PORT
          - name: POSTGRES_DB
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_DB
          - name: POSTGRES_USER
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_USER
          - name: PGPASSWORD
            valueFrom:
              secretKeyRef:
                name: songnodes-secrets
                key: POSTGRES_PASSWORD
    resources:
      requests:
        memory: 256Mi
        cpu: 100m
      limits:
        memory: 1Gi
        cpu: 500m

  seratoIntegration:
    enabled: false
    name: serato-integration
    component: tools
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_serato-integration
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8021
          targetPort: 8021
    containerPorts:
      http: 8021
    env:
      config:
        - POSTGRES_HOST
        - POSTGRES_PORT
        - POSTGRES_DB
        - POSTGRES_USER
      secret:
        POSTGRES_PASSWORD: POSTGRES_PASSWORD
    volumeMounts:
      - name: music-library
        mountPath: /music
        readOnly: true
    volumes:
      - name: music-library
        persistentVolumeClaim:
          claimName: serato-music-library
    persistence:
      enabled: true
      accessModes:
        - ReadWriteMany
      size: 100Gi
      storageClassName: ""
      selector: {}
    resources:
      requests:
        memory: 512Mi
        cpu: 200m
      limits:
        memory: 1Gi
        cpu: 800m
    probes:
      liveness:
        enabled: false
      readiness:
        enabled: false

  frontend:
    enabled: true
    name: frontend
    component: ui
    replicaCount: 1
    image:
      repository: localhost:5000/songnodes_frontend
      tag: latest
      pullPolicy: Always
    service:
      type: NodePort
      ports:
        http:
          port: 80
          targetPort: 80
          nodePort: 30006
    containerPorts:
      http: 80
    env:
      static:
        # Use empty values to force relative URLs (nginx proxy handles routing)
        VITE_REST_API_URL: ""
        VITE_GRAPH_API_URL: ""
        VITE_WEBSOCKET_URL: ""
    configMap:
      enabled: true
      name: frontend-nginx-config
      data:
        nginx.conf: |
          server {
              listen 80;
              server_name _;
              root /usr/share/nginx/html;
              index index.html;

              gzip on;
              gzip_vary on;
              gzip_min_length 1024;
              gzip_types text/plain text/css application/json application/javascript text/xml application/xml text/javascript;

              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-Content-Type-Options "nosniff" always;
              add_header X-XSS-Protection "1; mode=block" always;
              add_header Referrer-Policy "no-referrer-when-downgrade" always;

              location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
                  expires 1y;
                  add_header Cache-Control "public, immutable";
              }

              # API proxy routing - route to correct backend service based on path
              # Graph API endpoints
              location ~ ^/api/(graph|v1/visualization|user-setlists) {
                  proxy_pass http://graph-visualization:8084;
                  proxy_http_version 1.1;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
              }

              # REST API endpoints (artists, tracks, setlists, scraping, etc.)
              location /api/ {
                  proxy_pass http://rest-api:8082;
                  proxy_http_version 1.1;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }

              location / {
                  try_files $uri $uri/ /index.html;
              }

              location /health {
                  access_log off;
                  return 200 "healthy\n";
                  add_header Content-Type text/plain;
              }
          }
    resources:
      requests:
        memory: 32Mi
        cpu: 25m
      limits:
        memory: 64Mi
        cpu: 100m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /
          port: http
        initialDelaySeconds: 10
        periodSeconds: 10
      readiness:
        enabled: true
        httpGet:
          path: /
          port: http
        initialDelaySeconds: 5
        periodSeconds: 5
    volumeMounts:
      - name: frontend-nginx-config
        mountPath: /etc/nginx/conf.d/default.conf
        subPath: nginx.conf
    volumes:
      - name: frontend-nginx-config
        configMap:
          name: frontend-nginx-config

autoscaling:
  enabled: false  # Disabled: causes memory pressure, all services run single replica
  targets:
    restApi:
      minReplicas: 1
      maxReplicas: 1
      metrics:
        - type: Resource
          resource:
            name: cpu
            target:
              type: Utilization
              averageUtilization: 70
        - type: Resource
          resource:
            name: memory
            target:
              type: Utilization
              averageUtilization: 80
      behavior:
        scaleDown:
          stabilizationWindowSeconds: 300
          policies:
            - type: Percent
              value: 50
              periodSeconds: 60
            - type: Pods
              value: 2
              periodSeconds: 60
          selectPolicy: Min
        scaleUp:
          stabilizationWindowSeconds: 60
          policies:
            - type: Percent
              value: 100
              periodSeconds: 30
            - type: Pods
              value: 4
              periodSeconds: 30
          selectPolicy: Max

    graphVisualization:
      minReplicas: 1
      maxReplicas: 1
      metrics:
        - type: Resource
          resource:
            name: cpu
            target:
              type: Utilization
              averageUtilization: 75
        - type: Resource
          resource:
            name: memory
            target:
              type: Utilization
              averageUtilization: 80

    websocketApi:
      minReplicas: 1
      maxReplicas: 1
      metrics:
        - type: Resource
          resource:
            name: cpu
            target:
              type: Utilization
              averageUtilization: 70
        - type: Resource
          resource:
            name: memory
            target:
              type: Utilization
              averageUtilization: 75

    nlpProcessor:
      minReplicas: 1
      maxReplicas: 1
      metrics:
        - type: Resource
          resource:
            name: cpu
            target:
              type: Utilization
              averageUtilization: 80
        - type: Resource
          resource:
            name: memory
            target:
              type: Utilization
              averageUtilization: 85

    metadataEnrichment:
      minReplicas: 1
      maxReplicas: 1
      metrics:
        - type: Resource
          resource:
            name: cpu
            target:
              type: Utilization
              averageUtilization: 75
        - type: Resource
          resource:
            name: memory
            target:
              type: Utilization
              averageUtilization: 80


ingress:
  enabled: true
  className: nginx
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/websocket-services: websocket-api
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-origin: "*"
    nginx.ingress.kubernetes.io/cors-allow-methods: GET, POST, PUT, DELETE, OPTIONS
    nginx.ingress.kubernetes.io/cors-allow-headers: DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization
    nginx.ingress.kubernetes.io/limit-rps: "100"
    nginx.ingress.kubernetes.io/proxy-body-size: 10m
  hosts:
    - host: songnodes.example.com
      paths:
        - path: /
          pathType: Prefix
          service: frontend
          port: http
    - host: api.songnodes.example.com
      paths:
        - path: /api
          pathType: Prefix
          service: restApi
          port: http
        - path: /graph
          pathType: Prefix
          service: graphVisualization
          port: http
        - path: /ws
          pathType: Prefix
          service: websocketApi
          port: http
        - path: /nlp
          pathType: Prefix
          service: nlpProcessor
          port: http
        - path: /scraper
          pathType: Prefix
          service: scraperOrchestrator
          port: http
        - path: /enrich
          pathType: Prefix
          service: metadataEnrichment
          port: http
  tls: []
  additionalIngresses:
    singleHost:
      enabled: false
      host: songnodes.example.com

networkPolicy:
  enabled: true
  ingressControllerNamespaceLabel: ingress-nginx
  prometheusSelector:
    app.kubernetes.io/name: prometheus
  grafanaSelector:
    app.kubernetes.io/name: grafana

cronjobs:
  silverToGold:
    enabled: true
    schedule: "0 */2 * * *"
    image:
      repository: localhost:5000/songnodes_data-transformer
      tag: latest
      pullPolicy: Always
    intervalHours: 2
    batchSize: 50000
    startupDelaySeconds: 90
    concurrencyPolicy: Forbid
    restartPolicy: OnFailure
    successfulJobsHistoryLimit: 3
    failedJobsHistoryLimit: 3
    backoffLimit: 3
    activeDeadlineSeconds: 7200
    resources:
      requests:
        memory: 32Mi
        cpu: 25m
      limits:
        memory: 64Mi
        cpu: 100m
    podAnnotations: {}

  goldToOperational:
    enabled: true
    schedule: "17 * * * *"  # Run at 17 minutes past every hour (avoid hour boundaries)
    image:
      repository: localhost:5000/songnodes_gold-to-operational-etl
      tag: latest
      pullPolicy: IfNotPresent
    concurrencyPolicy: Forbid
    restartPolicy: OnFailure
    successfulJobsHistoryLimit: 3
    failedJobsHistoryLimit: 3
    backoffLimit: 3
    activeDeadlineSeconds: 3600  # 1 hour timeout
    resources:
      requests:
        memory: 256Mi
        cpu: 100m
      limits:
        memory: 1Gi
        cpu: 500m
    podAnnotations: {}

# PodDisruptionBudgets - Ensure minimum availability during disruptions
podDisruptionBudget:
  enabled: true
  services:
    postgres:
      enabled: true
      minAvailable: 1  # Critical: Always keep database available
    rabbitmq:
      enabled: true
      minAvailable: 1  # Critical: Message queue must stay up
    redis:
      enabled: true
      minAvailable: 1  # Critical: Cache must stay up
    rest-api:
      enabled: true
      minAvailable: 1  # Keep API available during disruptions
    graph-visualization:
      enabled: true
      minAvailable: 1  # Keep graph API available
    metadata-enrichment:
      enabled: true
      minAvailable: 1  # Keep enrichment service available
