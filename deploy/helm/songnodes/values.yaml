global:
  namespace: songnodes
  imagePullSecrets: []
  configMapName: songnodes-config
  secretName: songnodes-secrets
  commonLabels:
    app.kubernetes.io/part-of: songnodes
  commonAnnotations:
    deployment.kubernetes.io/revision: "1"

namespace:
  create: true
  name: songnodes
  labels: {}
  annotations: {}

config:
  create: true
  name: songnodes-config
  labels:
    app.kubernetes.io/name: songnodes
    app.kubernetes.io/component: config
  annotations: {}
  data:
    POSTGRES_HOST: postgres-0.postgres-service
    POSTGRES_PORT: "5432"
    POSTGRES_DB: musicdb
    POSTGRES_USER: musicdb_user
    REDIS_HOST: redis-service
    REDIS_PORT: "6379"
    RABBITMQ_HOST: rabbitmq-service
    RABBITMQ_PORT: "5672"
    RABBITMQ_USER: songnodesuser
    REST_API_HOST: rest-api-service
    REST_API_PORT: "8082"
    GRAPH_API_HOST: graph-visualization-service
    GRAPH_API_PORT: "8084"
    WEBSOCKET_API_HOST: websocket-api-service
    WEBSOCKET_API_PORT: "8083"
    METADATA_ENRICHMENT_HOST: metadata-enrichment-service
    METADATA_ENRICHMENT_PORT: "8020"
    METADATA_ENRICHMENT_URL: http://metadata-enrichment-service:8020
    ENVIRONMENT: production
    LOG_LEVEL: INFO
    CORS_ORIGINS: "*"
    SCRAPER_CONCURRENT_REQUESTS: "16"
    SCRAPER_DOWNLOAD_DELAY: "2.0"
    SCRAPER_AUTOTHROTTLE_ENABLED: "True"
    PROMETHEUS_ENABLED: "true"
    METRICS_PORT: "9090"

secrets:
  create: true
  name: songnodes-secrets
  type: Opaque
  labels:
    app.kubernetes.io/name: songnodes
    app.kubernetes.io/component: secrets
  annotations: {}
  stringData:
    POSTGRES_PASSWORD: CHANGE_ME_musicdb_secure_pass_2024
    REDIS_PASSWORD: CHANGE_ME_redis_secure_pass_2024
    RABBITMQ_PASS: CHANGE_ME_rabbitmq_secure_pass_2024
    SPOTIFY_CLIENT_ID: CHANGE_ME
    SPOTIFY_CLIENT_SECRET: CHANGE_ME
    TIDAL_CLIENT_ID: CHANGE_ME
    TIDAL_CLIENT_SECRET: CHANGE_ME
    TIDAL_API_TOKEN: CHANGE_ME
    LASTFM_API_KEY: CHANGE_ME
    YOUTUBE_API_KEY: CHANGE_ME
    DISCOGS_API_TOKEN: CHANGE_ME
    ANTHROPIC_API_KEY: CHANGE_ME
    PROXY_USERNAME: ""
    PROXY_PASSWORD: ""

postgres:
  enabled: true
  nameOverride: postgres
  replicaCount: 1
  service:
    type: ClusterIP
    port: 5432
    annotations: {}
    headless: true
  image:
    repository: postgres
    tag: 15-alpine
    pullPolicy: IfNotPresent
  env:
    pgdata: /var/lib/postgresql/data/pgdata
  persistence:
    enabled: true
    accessModes:
      - ReadWriteOnce
    size: 20Gi
    storageClassName: ""
  resources:
    requests:
      memory: 1Gi
      cpu: 500m
    limits:
      memory: 2Gi
      cpu: 1000m
  readinessProbe:
    enabled: true
    exec:
        command:
        - /bin/sh
        - -c
        - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
  livenessProbe:
    enabled: true
    exec:
        command:
        - /bin/sh
        - -c
        - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  initScripts:
    createConfigMap: true
    name: postgres-init-scripts
    data:
      README.md: |
        PostgreSQL initialization scripts should be mounted here.
        Copy contents from sql/init/ directory to this ConfigMap.

        Example:
        kubectl create configmap postgres-init-scripts \
          --from-file=sql/init/ \
          -n songnodes

redis:
  enabled: true
  nameOverride: redis
  replicaCount: 1
  service:
    type: ClusterIP
    port: 6379
    annotations: {}
  image:
    repository: redis
    tag: 7-alpine
    pullPolicy: IfNotPresent
  command:
    - redis-server
    - --requirepass
    - $(REDIS_PASSWORD)
    - --maxmemory
    - 512mb
    - --maxmemory-policy
    - allkeys-lru
    - --save
    - "900 1"
    - --save
    - "300 10"
    - --save
    - "60 10000"
  persistence:
    enabled: true
    existingClaim: ""
    accessModes:
      - ReadWriteOnce
    size: 5Gi
    storageClassName: ""
  resources:
    requests:
      memory: 256Mi
      cpu: 100m
    limits:
      memory: 512Mi
      cpu: 500m
  readinessProbe:
    enabled: true
    exec:
        command:
        - redis-cli
        - --pass
        - $(REDIS_PASSWORD)
        - ping
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
  livenessProbe:
    enabled: true
    exec:
        command:
        - redis-cli
        - --pass
        - $(REDIS_PASSWORD)
        - ping
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

rabbitmq:
  enabled: true
  nameOverride: rabbitmq
  replicaCount: 1
  service:
    type: ClusterIP
    ports:
      amqp: 5672
      management: 15672
    annotations: {}
    headless: true
  image:
    repository: rabbitmq
    tag: 3.12-management-alpine
    pullPolicy: IfNotPresent
  erlangCookie: songnodes-secret-cookie
  persistence:
    enabled: true
    accessModes:
      - ReadWriteOnce
    size: 10Gi
    storageClassName: ""
  resources:
    requests:
      memory: 512Mi
      cpu: 250m
    limits:
      memory: 1Gi
      cpu: 1000m
  readinessProbe:
    enabled: true
    exec:
        command:
        - rabbitmq-diagnostics
        - -q
        - check_port_connectivity
    initialDelaySeconds: 20
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  livenessProbe:
    enabled: true
    exec:
        command:
        - rabbitmq-diagnostics
        - -q
        - ping
    initialDelaySeconds: 60
    periodSeconds: 30
    timeoutSeconds: 10
    failureThreshold: 3

services:
  restApi:
    enabled: true
    name: rest-api
    component: backend
    replicaCount: 3
    image:
      repository: songnodes/rest-api
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8082
          targetPort: 8082
        metrics:
          port: 9090
          targetPort: 9090
    podAnnotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9090"
      prometheus.io/path: /metrics
    containerPorts:
      http: 8082
      metrics: 9090
    env:
      config:
        - POSTGRES_HOST
        - POSTGRES_PORT
        - POSTGRES_DB
        - POSTGRES_USER
        - REDIS_HOST
        - REDIS_PORT
        - LOG_LEVEL
        - ENVIRONMENT
      secret:
        POSTGRES_PASSWORD: POSTGRES_PASSWORD
        REDIS_PASSWORD: REDIS_PASSWORD
        DATABASE_URL: DATABASE_URL
    extraEnv: []
    initContainers:
      - name: wait-for-postgres
        image: postgres:15-alpine
        command:
          - sh
          - -c
          - |
            for i in $(seq 1 40); do
              pg_isready -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d "$POSTGRES_DB" && exit 0
              echo "Waiting for postgres at $POSTGRES_HOST:$POSTGRES_PORT..."
              sleep 3
            done
            echo "Postgres not reachable, giving up."
            exit 1
        env:
          - name: POSTGRES_HOST
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_HOST
          - name: POSTGRES_PORT
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_PORT
          - name: POSTGRES_DB
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_DB
          - name: POSTGRES_USER
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_USER
          - name: PGPASSWORD
            valueFrom:
              secretKeyRef:
                name: songnodes-secrets
                key: POSTGRES_PASSWORD
    resources:
      requests:
        memory: 256Mi
        cpu: 100m
      limits:
        memory: 512Mi
        cpu: 500m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 5
        failureThreshold: 3
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 10
        periodSeconds: 5
        timeoutSeconds: 3
        failureThreshold: 3
      startup:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 0
        periodSeconds: 5
        timeoutSeconds: 3
        failureThreshold: 30

  graphVisualization:
    enabled: true
    name: graph-visualization
    component: backend
    replicaCount: 2
    image:
      repository: songnodes/graph-visualization-api
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8084
          targetPort: 8084
        metrics:
          port: 9090
          targetPort: 9090
    podAnnotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9090"
    containerPorts:
      http: 8084
      metrics: 9090
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 1000m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 10
        periodSeconds: 5

  websocketApi:
    enabled: true
    name: websocket-api
    component: backend
    replicaCount: 2
    image:
      repository: songnodes/websocket-api
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8083
          targetPort: 8083
    containerPorts:
      http: 8083
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 256Mi
        cpu: 100m
      limits:
        memory: 512Mi
        cpu: 500m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 20
        periodSeconds: 10
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 10
        periodSeconds: 5

  nlpProcessor:
    enabled: true
    name: nlp-processor
    component: backend
    replicaCount: 2
    image:
      repository: songnodes/nlp-processor
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8086
          targetPort: 8086
    containerPorts:
      http: 8086
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 512Mi
        cpu: 200m
      limits:
        memory: 1Gi
        cpu: 800m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 10
        periodSeconds: 5

  scraperOrchestrator:
    enabled: true
    name: scraper-orchestrator
    component: scraper
    replicaCount: 2
    image:
      repository: songnodes/scraper-orchestrator
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8085
          targetPort: 8085
    containerPorts:
      http: 8085
    envFrom:
      configMap: true
      secret: true
    resources:
      requests:
        memory: 512Mi
        cpu: 250m
      limits:
        memory: 1Gi
        cpu: 1000m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 10
        periodSeconds: 5

  metadataEnrichment:
    enabled: true
    name: metadata-enrichment
    component: enrichment
    replicaCount: 2
    image:
      repository: songnodes/metadata-enrichment
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8020
          targetPort: 8020
        metrics:
          port: 9090
          targetPort: 9090
    podAnnotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9090"
      prometheus.io/path: /metrics
    containerPorts:
      http: 8020
      metrics: 9090
    env:
      config:
        - POSTGRES_HOST
        - POSTGRES_PORT
        - POSTGRES_DB
        - POSTGRES_USER
        - REDIS_HOST
        - REDIS_PORT
        - LOG_LEVEL
        - ENVIRONMENT
      secret:
        POSTGRES_PASSWORD: POSTGRES_PASSWORD
        REDIS_PASSWORD: REDIS_PASSWORD
        SPOTIFY_CLIENT_ID: SPOTIFY_CLIENT_ID
        SPOTIFY_CLIENT_SECRET: SPOTIFY_CLIENT_SECRET
        TIDAL_CLIENT_ID: TIDAL_CLIENT_ID
        TIDAL_CLIENT_SECRET: TIDAL_CLIENT_SECRET
        LASTFM_API_KEY: LASTFM_API_KEY
        DISCOGS_API_TOKEN: DISCOGS_API_TOKEN
    initContainers:
      - name: wait-for-postgres
        image: postgres:15-alpine
        command:
          - sh
          - -c
          - |
            for i in $(seq 1 40); do
              pg_isready -h "$POSTGRES_HOST" -p "$POSTGRES_PORT" -U "$POSTGRES_USER" -d "$POSTGRES_DB" && exit 0
              echo "Waiting for postgres at $POSTGRES_HOST:$POSTGRES_PORT..."
              sleep 3
            done
            echo "Postgres not reachable, giving up."
            exit 1
        env:
          - name: POSTGRES_HOST
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_HOST
          - name: POSTGRES_PORT
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_PORT
          - name: POSTGRES_DB
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_DB
          - name: POSTGRES_USER
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: POSTGRES_USER
          - name: PGPASSWORD
            valueFrom:
              secretKeyRef:
                name: songnodes-secrets
                key: POSTGRES_PASSWORD
      - name: wait-for-redis
        image: redis:7-alpine
        command:
          - sh
          - -c
          - |
            for i in $(seq 1 30); do
              redis-cli -h "$REDIS_HOST" -p "$REDIS_PORT" -a "$REDIS_PASSWORD" ping && exit 0
              echo "Waiting for redis at $REDIS_HOST:$REDIS_PORT..."
              sleep 2
            done
            echo "Redis not reachable, giving up."
            exit 1
        env:
          - name: REDIS_HOST
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: REDIS_HOST
          - name: REDIS_PORT
            valueFrom:
              configMapKeyRef:
                name: songnodes-config
                key: REDIS_PORT
          - name: REDIS_PASSWORD
            valueFrom:
              secretKeyRef:
                name: songnodes-secrets
                key: REDIS_PASSWORD
    resources:
      requests:
        memory: 512Mi
        cpu: 200m
      limits:
        memory: 1Gi
        cpu: 800m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 5
        failureThreshold: 3
      readiness:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 10
        periodSeconds: 5
        timeoutSeconds: 3
        failureThreshold: 3
      startup:
        enabled: true
        httpGet:
          path: /health
          port: http
        initialDelaySeconds: 0
        periodSeconds: 5
        timeoutSeconds: 3
        failureThreshold: 30

  seratoIntegration:
    enabled: false
    name: serato-integration
    component: tools
    replicaCount: 1
    image:
      repository: songnodes/serato-integration
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 8021
          targetPort: 8021
    containerPorts:
      http: 8021
    env:
      config:
        - POSTGRES_HOST
        - POSTGRES_PORT
        - POSTGRES_DB
        - POSTGRES_USER
      secret:
        POSTGRES_PASSWORD: POSTGRES_PASSWORD
    volumeMounts:
      - name: music-library
        mountPath: /music
        readOnly: true
    volumes:
      - name: music-library
        persistentVolumeClaim:
          claimName: serato-music-library
    persistence:
      enabled: true
      accessModes:
        - ReadWriteMany
      size: 100Gi
      storageClassName: ""
      selector: {}
    resources:
      requests:
        memory: 512Mi
        cpu: 200m
      limits:
        memory: 1Gi
        cpu: 800m
    probes:
      liveness:
        enabled: false
      readiness:
        enabled: false

  frontend:
    enabled: true
    name: frontend
    component: ui
    replicaCount: 3
    image:
      repository: songnodes/frontend
      tag: latest
      pullPolicy: Always
    service:
      type: ClusterIP
      ports:
        http:
          port: 80
          targetPort: 80
    containerPorts:
      http: 80
    env:
      static:
        VITE_REST_API_URL: http://rest-api-service:8082
        VITE_GRAPH_API_URL: http://graph-visualization-service:8084
        VITE_WEBSOCKET_URL: ws://websocket-api-service:8083
    configMap:
      enabled: true
      name: frontend-nginx-config
      data:
        nginx.conf: |
          server {
              listen 80;
              server_name _;
              root /usr/share/nginx/html;
              index index.html;

              gzip on;
              gzip_vary on;
              gzip_min_length 1024;
              gzip_types text/plain text/css application/json application/javascript text/xml application/xml text/javascript;

              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-Content-Type-Options "nosniff" always;
              add_header X-XSS-Protection "1; mode=block" always;
              add_header Referrer-Policy "no-referrer-when-downgrade" always;

              location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
                  expires 1y;
                  add_header Cache-Control "public, immutable";
              }

              location / {
                  try_files $uri $uri/ /index.html;
              }

              location /health {
                  access_log off;
                  return 200 "healthy\n";
                  add_header Content-Type text/plain;
              }
          }
    resources:
      requests:
        memory: 128Mi
        cpu: 50m
      limits:
        memory: 256Mi
        cpu: 200m
    probes:
      liveness:
        enabled: true
        httpGet:
          path: /
          port: http
        initialDelaySeconds: 10
        periodSeconds: 10
      readiness:
        enabled: true
        httpGet:
          path: /
          port: http
        initialDelaySeconds: 5
        periodSeconds: 5
    volumeMounts:
      - name: frontend-nginx-config
        mountPath: /etc/nginx/conf.d/default.conf
        subPath: nginx.conf
    volumes:
      - name: frontend-nginx-config
        configMap:
          name: frontend-nginx-config

autoscaling:
  enabled: true
  targets:
    restApi:
      minReplicas: 3
      maxReplicas: 10
      metrics:
        - type: Resource
          resource:
            name: cpu
            target:
              type: Utilization
              averageUtilization: 70
        - type: Resource
          resource:
            name: memory
            target:
              type: Utilization
              averageUtilization: 80
      behavior:
        scaleDown:
          stabilizationWindowSeconds: 300
          policies:
            - type: Percent
              value: 50
              periodSeconds: 60
            - type: Pods
              value: 2
              periodSeconds: 60
          selectPolicy: Min
        scaleUp:
          stabilizationWindowSeconds: 60
          policies:
            - type: Percent
              value: 100
              periodSeconds: 30
            - type: Pods
              value: 4
              periodSeconds: 30
          selectPolicy: Max

    graphVisualization:
      minReplicas: 2
      maxReplicas: 8
      metrics:
        - type: Resource
          resource:
            name: cpu
            target:
              type: Utilization
              averageUtilization: 75
        - type: Resource
          resource:
            name: memory
            target:
              type: Utilization
              averageUtilization: 80

    websocketApi:
      minReplicas: 2
      maxReplicas: 6
      metrics:
        - type: Resource
          resource:
            name: cpu
            target:
              type: Utilization
              averageUtilization: 70
        - type: Resource
          resource:
            name: memory
            target:
              type: Utilization
              averageUtilization: 75

    nlpProcessor:
      minReplicas: 2
      maxReplicas: 5
      metrics:
        - type: Resource
          resource:
            name: cpu
            target:
              type: Utilization
              averageUtilization: 80
        - type: Resource
          resource:
            name: memory
            target:
              type: Utilization
              averageUtilization: 85

    metadataEnrichment:
      minReplicas: 2
      maxReplicas: 6
      metrics:
        - type: Resource
          resource:
            name: cpu
            target:
              type: Utilization
              averageUtilization: 75
        - type: Resource
          resource:
            name: memory
            target:
              type: Utilization
              averageUtilization: 80

    frontend:
      minReplicas: 3
      maxReplicas: 10
      metrics:
        - type: Resource
          resource:
            name: cpu
            target:
              type: Utilization
              averageUtilization: 70
        - type: Resource
          resource:
            name: memory
            target:
              type: Utilization
              averageUtilization: 75
      behavior:
        scaleUp:
          stabilizationWindowSeconds: 30
          policies:
            - type: Percent
              value: 100
              periodSeconds: 15
            - type: Pods
              value: 5
              periodSeconds: 15
          selectPolicy: Max

ingress:
  enabled: true
  className: nginx
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/websocket-services: websocket-api-service
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-origin: "*"
    nginx.ingress.kubernetes.io/cors-allow-methods: GET, POST, PUT, DELETE, OPTIONS
    nginx.ingress.kubernetes.io/cors-allow-headers: DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization
    nginx.ingress.kubernetes.io/limit-rps: "100"
    nginx.ingress.kubernetes.io/proxy-body-size: 10m
  hosts:
    - host: songnodes.example.com
      paths:
        - path: /
          pathType: Prefix
          service: frontend
          port: http
    - host: api.songnodes.example.com
      paths:
        - path: /api
          pathType: Prefix
          service: restApi
          port: http
        - path: /graph
          pathType: Prefix
          service: graphVisualization
          port: http
        - path: /ws
          pathType: Prefix
          service: websocketApi
          port: http
        - path: /nlp
          pathType: Prefix
          service: nlpProcessor
          port: http
        - path: /scraper
          pathType: Prefix
          service: scraperOrchestrator
          port: http
        - path: /enrich
          pathType: Prefix
          service: metadataEnrichment
          port: http
  tls: []
  additionalIngresses:
    singleHost:
      enabled: false
      host: songnodes.example.com

networkPolicy:
  enabled: true
  ingressControllerNamespaceLabel: ingress-nginx
  prometheusSelector:
    app.kubernetes.io/name: prometheus
  grafanaSelector:
    app.kubernetes.io/name: grafana
